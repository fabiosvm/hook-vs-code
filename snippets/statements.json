{
	"use declaration": {
		"prefix": "use",
		"body": [
			"use ${1:name};"
		]
	},
	"use..as declaration": {
		"prefix": "usea",
		"body": [
			"use ${1:name} as ${2:name};"
		]
	},
	"destructured use declaration": {
		"prefix": "use{",
		"body": [
			"use { ${1:name} } in ${2:name};"
		]
	},
	"constant declaration": {
		"prefix": "const",
		"body": [
			"const ${1:name} = ${2:expression};"
		]
	},
	"unpacking to constant": {
		"prefix": "const[",
		"body": [
			"const [ ${1:name} ] = ${2:expression};"
		]
	},
	"destructuring to constant": {
		"prefix": "const{",
		"body": [
			"const { ${1:name} } = ${2:expression};"
		]
	},
	"variable declaration": {
		"prefix": "let",
		"body": [
			"let ${1:name} = ${2:expression};"
		]
	},
	"unpacking to variable": {
		"prefix": "let[",
		"body": [
			"let [ ${1:name} ] = ${2:expression};"
		]
	},
	"destructuring to variable": {
		"prefix": "let{",
		"body": [
			"let { ${1:name} } = ${2:expression};"
		]
	},
	"struct declaration": {
		"prefix": "struct",
		"body": [
			"struct ${1:name} {",
			"  ${2:field},",
			"}"
		]
	},
	"anonymous struct": {
		"prefix": "structa",
		"body": [
			"struct {",
			"  ${1:field},",
			"}"
		]
	},
	"function declaration": {
		"prefix": "fn",
		"body": [
			"fn ${1:name} (${2:param}) {",
			"  ${3:statement};",
			"}"
		]
	},
	"anonymous function": {
		"prefix": "fna",
		"body": [
			"fn (${1:param}) {",
			"  ${2:statement};",
			"}"
		]
	},
	"delete statement": {
		"prefix": "del",
		"body": [
			"delete ${1:name}[${2:expression}];"
		]
	},
	"if statement": {
		"prefix": "if",
		"body": [
			"if (${1:expression}) {",
			"  ${2:statement};",
			"}"
		]
	},
	"if..else statement": {
		"prefix": "ifel",
		"body": [
			"if (${1:expression}) {",
			"  ${2:statement};",
			"} else {",
			"  ${3:statement};",
			"}"
		]
	},
	"if expression": {
		"prefix": "ife",
		"body": [
			"if (${1:expression}) ${2:expression} else ${3:expression}"
		]
	},
	"match statement": {
		"prefix": "match",
		"body": [
			"match (${1:expression}) {",
			"  ${2:expression} => ${3:statement};",
			"}"
		]
	},
	"match.._ statement": {
		"prefix": "match_",
		"body": [
			"match (${1:expression}) {",
			"  ${2:expression} => ${3:statement};",
			"  _ => ${4:statement};",
			"}"
		]
	},
	"match expression": {
		"prefix": "matche",
		"body": [
			"match (${1:expression}) {",
			"  ${2:expression} => ${3:expression},",
			"  _ => ${4:expression}",
			"}"
		]
	},
	"loop statement": {
		"prefix": "loop",
		"body": [
			"loop {",
			"  ${1:statement};",
			"}"
		]
	},
	"while statement": {
		"prefix": "while",
		"body": [
			"while (${1:expression}) {",
			"  ${2:statement};",
			"}"
		]
	},
	"do..while statement": {
		"prefix": "do",
		"body": [
			"do {",
			"  ${1:statement};",
			"} while (${2:expression});"
		]
	},
	"for statement": {
		"prefix": "for",
		"body": [
			"for (let i = ${1:0}; i < ${2:n}; ${3:i++}) {",
			"  ${4:statement};",
			"}"
		]
	},
	"continue": {
		"prefix": "co",
		"body": [
			"continue;"
		]
	},
	"break": {
		"prefix": "br",
		"body": [
			"break;"
		]
	},
	"return": {
		"prefix": "ret",
		"body": [
			"return ${1:expression};"
		]
	},
	"return null": {
		"prefix": "ret;",
		"body": [
			"return;"
		]
	}
}
